// Code generated by protoc-gen-go.
// source: metrics.proto
// DO NOT EDIT!

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	metrics.proto

It has these top-level messages:
	Error
	Metric
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Agg int32

const (
	Agg_SUM Agg = 0
)

var Agg_name = map[int32]string{
	0: "SUM",
}
var Agg_value = map[string]int32{
	"SUM": 0,
}

func (x Agg) String() string {
	return proto.EnumName(Agg_name, int32(x))
}

type Error struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}

type Metric struct {
	Name         string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Labels       map[string]string `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Ts           int64             `protobuf:"varint,3,opt,name=ts" json:"ts,omitempty"`
	Aggregations []Agg             `protobuf:"varint,4,rep,name=aggregations,enum=metricd.Agg" json:"aggregations,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*Metric_IntValue
	//	*Metric_DoubleValue
	//	*Metric_StringValue
	Value isMetric_Value `protobuf_oneof:"Value"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}

type isMetric_Value interface {
	isMetric_Value()
}

type Metric_IntValue struct {
	IntValue int64 `protobuf:"varint,10,opt,name=int_value,oneof"`
}
type Metric_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,11,opt,name=double_value,oneof"`
}
type Metric_StringValue struct {
	StringValue string `protobuf:"bytes,12,opt,name=string_value,oneof"`
}

func (*Metric_IntValue) isMetric_Value()    {}
func (*Metric_DoubleValue) isMetric_Value() {}
func (*Metric_StringValue) isMetric_Value() {}

func (m *Metric) GetValue() isMetric_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Metric) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Metric) GetIntValue() int64 {
	if x, ok := m.GetValue().(*Metric_IntValue); ok {
		return x.IntValue
	}
	return 0
}

func (m *Metric) GetDoubleValue() float64 {
	if x, ok := m.GetValue().(*Metric_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (m *Metric) GetStringValue() string {
	if x, ok := m.GetValue().(*Metric_StringValue); ok {
		return x.StringValue
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Metric) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Metric_OneofMarshaler, _Metric_OneofUnmarshaler, []interface{}{
		(*Metric_IntValue)(nil),
		(*Metric_DoubleValue)(nil),
		(*Metric_StringValue)(nil),
	}
}

func _Metric_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Metric)
	// Value
	switch x := m.Value.(type) {
	case *Metric_IntValue:
		b.EncodeVarint(10<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IntValue))
	case *Metric_DoubleValue:
		b.EncodeVarint(11<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.DoubleValue))
	case *Metric_StringValue:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.StringValue)
	case nil:
	default:
		return fmt.Errorf("Metric.Value has unexpected type %T", x)
	}
	return nil
}

func _Metric_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Metric)
	switch tag {
	case 10: // Value.int_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Metric_IntValue{int64(x)}
		return true, err
	case 11: // Value.double_value
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &Metric_DoubleValue{math.Float64frombits(x)}
		return true, err
	case 12: // Value.string_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Metric_StringValue{x}
		return true, err
	default:
		return false, nil
	}
}

func init() {
	proto.RegisterType((*Error)(nil), "metricd.Error")
	proto.RegisterType((*Metric)(nil), "metricd.Metric")
	proto.RegisterEnum("metricd.Agg", Agg_name, Agg_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Server service

type ServerClient interface {
	Report(ctx context.Context, opts ...grpc.CallOption) (Server_ReportClient, error)
}

type serverClient struct {
	cc *grpc.ClientConn
}

func NewServerClient(cc *grpc.ClientConn) ServerClient {
	return &serverClient{cc}
}

func (c *serverClient) Report(ctx context.Context, opts ...grpc.CallOption) (Server_ReportClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Server_serviceDesc.Streams[0], c.cc, "/metricd.Server/Report", opts...)
	if err != nil {
		return nil, err
	}
	x := &serverReportClient{stream}
	return x, nil
}

type Server_ReportClient interface {
	Send(*Metric) error
	Recv() (*Error, error)
	grpc.ClientStream
}

type serverReportClient struct {
	grpc.ClientStream
}

func (x *serverReportClient) Send(m *Metric) error {
	return x.ClientStream.SendMsg(m)
}

func (x *serverReportClient) Recv() (*Error, error) {
	m := new(Error)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Server service

type ServerServer interface {
	Report(Server_ReportServer) error
}

func RegisterServerServer(s *grpc.Server, srv ServerServer) {
	s.RegisterService(&_Server_serviceDesc, srv)
}

func _Server_Report_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ServerServer).Report(&serverReportServer{stream})
}

type Server_ReportServer interface {
	Send(*Error) error
	Recv() (*Metric, error)
	grpc.ServerStream
}

type serverReportServer struct {
	grpc.ServerStream
}

func (x *serverReportServer) Send(m *Error) error {
	return x.ServerStream.SendMsg(m)
}

func (x *serverReportServer) Recv() (*Metric, error) {
	m := new(Metric)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Server_serviceDesc = grpc.ServiceDesc{
	ServiceName: "metricd.Server",
	HandlerType: (*ServerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Report",
			Handler:       _Server_Report_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}
